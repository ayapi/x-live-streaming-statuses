# Implementation Plan

- [x] 1. プロジェクト初期設定と共通型定義
- [x] 1.1 TypeScriptプロジェクトの初期化と共通型の定義
  - Node.js 18+ / TypeScript 5.x プロジェクトをセットアップし、tsconfig.json（strict mode）とビルドスクリプトを構成する
  - Result型ユーティリティを定義する（成功/失敗を明示的に表現する型、例外ではなく戻り値でエラーを伝搬する仕組み）
  - ドメインモデルの型定義を作成する: ブロードキャスト情報、チャット認証情報、生チャットメッセージ、パース済みコメント、ブロードキャスト状態
  - エラー型を定義する: ブロードキャストエラー、トークンエラー、送信エラー、設定エラー
  - 構造化ログ出力のユーティリティ関数を作成する（`[timestamp] [level] [component] message` 形式）
  - _Requirements: 4.3_

- [x] 2. ブロードキャスト解決機能の実装
- [x] 2.1 (P) URL解析とX APIからのブロードキャストメタデータ取得
  - Xライブ配信URLからブロードキャストIDを抽出する機能を実装する（`x.com/i/broadcasts/{id}`、`twitter.com/i/broadcasts/{id}`、直接ID入力の3パターンに対応）
  - X API `broadcasts/show.json` を呼び出してブロードキャストのメタデータ（media_key、タイトル、状態、配信者情報、開始時刻）を取得する
  - 配信が見つからない場合、既に終了している場合、APIエラーの場合にそれぞれ適切なエラーを返す
  - 取得成功時にブロードキャスト情報（配信タイトル、配信者名）をログ出力する
  - _Requirements: 1.1, 3.1_

- [x] 3. メッセージ解析と重複フィルタの実装
- [x] 3.1 (P) チャットメッセージの解析とフィールドマッピング
  - Periscope Chat APIから返される生メッセージ配列を受け取り、チャットメッセージ（kind:1）のみを抽出する（kind:2のシステムイベントはスキップ）
  - 二段階のJSONパースを実行する: 外側のpayload文字列をパースし、さらに内側のbody文字列をパースしてコメント本文を取得する
  - X Liveのフィールドをわんコメ形式にマッピングする: 投稿者表示名→name、Twitter ID→userId、プロフィール画像URL→profileImage、コメント本文→comment、UUID→id、タイムスタンプ（ミリ秒）→timestamp
  - JSONパースに失敗したメッセージはスキップし、警告ログを出力する（パイプライン全体を止めない）
  - _Requirements: 1.2, 2.2_

- [x] 3.2 (P) 重複コメントの検出・除外フィルタ
  - 送信済みコメントのUUIDをインメモリSetで管理し、O(1)の重複判定を行う
  - 送信成功時にUUIDを記録するメソッドと、既に送信済みかを判定するメソッドを提供する
  - Setのサイズが上限（10,000件）に達した場合、最も古いエントリから順に削除してメモリを制限する
  - _Requirements: 5.1, 5.2, 2.3_

- [x] 4. チャットトークン管理の実装
- [x] 4.1 (P) chatTokenの取得とaccess_tokenへの交換
  - X API `live_video_stream/status/{media_key}.json` を呼び出して、chatToken（JWT）を取得する
  - chatTokenのJWTペイロードからexp（有効期限）フィールドをデコードして保持する
  - Periscope API `accessChatPublic` にchatTokenをPOSTして、access_token・chatmanサーバーエンドポイント・room_idを取得する
  - ストリームが見つからない・オフライン・チャットアクセス拒否の各エラーケースを処理する
  - _Requirements: 4.1_

- [x] 4.2 トークンの有効期限監視と自動リフレッシュ
  - トークンの有効期限の80%が経過した時点でリフレッシュが必要と判断するロジックを実装する
  - リフレッシュ処理として、live_video_stream/statusとaccessChatPublicの再呼び出しを行い、新しいaccess_tokenとendpointを取得する
  - リフレッシュ失敗時はブロードキャスト解決からのフルフロー再取得を試み、それも失敗した場合は指数バックオフでリトライする
  - _Requirements: 4.1_

- [x] 5. チャットポーリングの実装
- [x] 5.1 cursorベースのチャット履歴ポーリング
  - Periscope Chat API `chatapi/v1/history` にaccess_token・cursor・limit・sinceをPOSTして、チャットメッセージと次回cursorを取得する
  - 初回ポーリングではcursorを空文字列・sinceを0に設定して全履歴を取得し、以降は前回のcursorを使用して差分のみ取得する
  - 設定可能なポーリング間隔（デフォルト3秒）でループを実行し、取得したメッセージをコールバックで通知する
  - ポーリングループの開始・停止を制御できるようにし、停止時は現在のcursorを保持して再開時に利用可能にする
  - 401エラー（トークン無効）時はトークンリフレッシュを要求し、429エラー（レート制限）時はポーリング間隔を自動延長する
  - _Requirements: 1.3, 5.2_

- [x] 6. わんコメクライアントの実装
- [x] 6.1 (P) わんコメAPIへのコメント送信
  - パース済みコメントをわんコメの `POST /api/comments` が期待するJSON形式に変換する（service.id、comment.id、userId、name、comment、profileImage、badges空配列、hasGift:false、isOwner、timestamp文字列）
  - わんコメのHTTPサーバー（ホスト・ポート設定可能、デフォルトlocalhost:11180）にPOSTリクエストを送信する
  - isOwnerフラグは、コメント投稿者のtwitter_idが配信者と一致する場合にtrueを設定する
  - 送信成功時（200 OK）にログを出力し、成功を呼び出し元に通知する
  - _Requirements: 2.1, 2.2_

- [x] 6.2 わんコメ送信のリトライとコメントバッファリング
  - 送信失敗時に指数バックオフ（1秒→2秒→4秒）で最大3回リトライする機能を実装する
  - わんコメに接続できない場合（ECONNREFUSED）はバッファモードに移行し、コメントをメモリ内キュー（最大1,000件）に蓄積する
  - バッファモード中は30秒間隔でわんコメへの接続を再試行し、回復時にバッファ内のコメントをFIFO順で送信する
  - バッファが上限に達した場合は古いコメントから破棄し、バッファサイズをログ出力する
  - service.idが無効（400レスポンス）の場合はユーザーに設定確認を促すエラーメッセージを表示する
  - _Requirements: 2.4, 4.2_

- [x] 7. 配信状態監視の実装
- [x] 7.1 (P) ブロードキャスト状態の定期監視と配信終了検出
  - X API `broadcasts/show.json` を30秒間隔でポーリングし、配信状態（state フィールド）を監視する
  - 状態が "RUNNING" から "ENDED" に変化したことを検出し、コールバックで通知する
  - 状態監視の開始・停止を制御できるようにし、チャットポーリングとは独立して動作させる
  - 配信終了検出時のログ出力を行う
  - _Requirements: 1.4_

- [x] 8. CLIとパイプライン統合
- [x] 8.1 コマンドライン引数の解析と設定バリデーション
  - process.argvを直接パースして以下の引数を受け付ける: ブロードキャストURL（必須）、わんコメ枠ID（必須）、わんコメホスト（デフォルト: localhost）、わんコメポート（デフォルト: 11180）、ポーリング間隔（デフォルト: 3000ms）
  - 必須引数（ブロードキャストURL、わんコメ枠ID）が不足している場合に、不足項目を明示したエラーメッセージを表示して終了する
  - URLの形式バリデーション、ポート番号の数値バリデーションを行う
  - 起動時に全設定値をログ出力する（トークン等の秘密情報は除く）
  - _Requirements: 3.1, 3.2, 3.3, 3.4_

- [x] 8.2 メインパイプラインの組み立てと実行制御
  - 全コンポーネント（BroadcastResolver → TokenProvider → ChatPoller → MessageParser → DuplicateFilter → OneCommeClient、StatusMonitor）を直列パイプラインとして接続する
  - ポーリングループ内で、メッセージ取得→パース→重複フィルタ→わんコメ送信の一連のフローを実行する
  - ポーリングループ内でトークンの有効期限を毎回チェックし、必要に応じてリフレッシュを挿入する
  - SIGINT/SIGTERMシグナル受信時にポーリングループを安全に停止し、未送信バッファをフラッシュしてからプロセスを終了する
  - 予期しない例外はトップレベルでキャッチし、エラーログ出力後にポーリングを継続する（クラッシュしない）
  - 処理済みコメント数、エラー数、バッファサイズを定期的にサマリーログとして出力する
  - _Requirements: 4.3, 4.4_

- [x]* 9. テストの実装
- [x]* 9.1 (P) ユニットテスト
  - MessageParserのテスト: 正常な二重ネストJSON解析、不正JSON時のスキップ動作、kind:2メッセージのフィルタリング、各フィールドの正確なマッピング
  - DuplicateFilterのテスト: 新規UUID判定、重複UUID検出、サイズ上限超過時の古いエントリ削除
  - BroadcastResolverのテスト: x.com/twitter.com/直接ID各形式からのブロードキャストID抽出
  - CLI設定パーサーのテスト: 引数解析、デフォルト値適用、バリデーションエラー
  - _Requirements: 1.1, 1.2, 2.2, 3.1, 3.2, 3.3, 3.4, 5.1, 5.2_

- [x]* 9.2 統合テストとE2Eテスト
  - モックHTTPサーバーを使用したTokenProviderの統合テスト: chatToken取得→access_token交換のフルフロー
  - モックHTTPサーバーを使用したOneCommeClientの統合テスト: 正常送信、接続拒否時のバッファリング、接続回復時のフラッシュ
  - モックX API + モックわんコメAPIを使用したフルパイプラインE2Eテスト: 起動→コメント取得→変換→送信→重複スキップの一連フロー
  - グレースフルシャットダウンテスト: SIGINTシグナル送信→ポーリング停止→バッファフラッシュ→プロセス正常終了の検証
  - _Requirements: 1.1, 1.2, 1.3, 2.1, 2.3, 2.4, 4.1, 4.2, 4.4, 5.1_
